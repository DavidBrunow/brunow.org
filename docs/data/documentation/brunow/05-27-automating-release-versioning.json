{"metadata":{"platforms":[{"name":"Brunow","introducedAt":"2024.05.27"}],"images":[{"type":"card","identifier":"conventionalCommitParserReleaseNotesFromDanger.png"}],"title":"Automating Release Versioning","modules":[{"name":"Brunow"}],"color":{"standardColorIdentifier":"purple"}},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"text","text":"By adopting a standard called"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/www.conventionalcommits.org\/en\/v1.0.0\/","type":"reference"},{"text":" for the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"git commits on your repo, and adding a tool that parses those commits, you can"},{"type":"text","text":" "},{"type":"text","text":"automate the versioning of code that follows semantic versioning. I’ve written a"},{"type":"text","text":" "},{"text":"tool that parses Conventional Commits and I’ll talk through how I use it to","type":"text"},{"type":"text","text":" "},{"text":"automate my releases.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"About-Conventional-Commits","type":"heading","text":"About Conventional Commits"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conventional commits are a style of commit that originated in the Angular"},{"type":"text","text":" "},{"type":"text","text":"development team and are meant to solve the problem of automating versioning. I"},{"type":"text","text":" "},{"type":"text","text":"came across the idea of conventional commits years ago, before the standard"},{"type":"text","text":" "},{"type":"text","text":"linked above was created, when looking to automate module releases at a previous"},{"text":" ","type":"text"},{"text":"job.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Conventional commits are git commits which follow a specific format, for"},{"text":" ","type":"text"},{"type":"text","text":"example:"}],"type":"paragraph"},{"type":"codeListing","code":["feat: Add endpoint to the InputField API for formatting"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"feat:","type":"codeVoice"},{"text":" prefix in this format indicates that the change is a feature, which","type":"text"},{"type":"text","text":" "},{"text":"means that the semantic version’s minor version should be increased by one, and","type":"text"},{"text":" ","type":"text"},{"text":"the description for that feature is “Add endpoint to the InputField API for","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"formatting”."}]},{"anchor":"Implementing-Conventional-Commit-Parsing","level":2,"text":"Implementing Conventional Commit Parsing","type":"heading"},{"inlineContent":[{"text":"To implement this parsing, we need two things:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"An automation workflow that uses the parsed values to inform versioning, and"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Ergonomic interaction points to inform the person using these formatted","type":"text"},{"type":"text","text":" "},{"type":"text","text":"commits about what the automation does"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"I’ve written a command line tool, ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/DavidBrunow\/swift-conventional-commit-parser","type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which is integral to the workflow I use for release automation."},{"type":"reference","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/05-27-automating-release-versioning#Footnotes","overridingTitle":"¹","overridingTitleInlineContent":[{"text":"¹","type":"text"}],"isActive":true}]},{"inlineContent":[{"type":"text","text":"Swift Conventional Commit Parser has two commands, one for running on a pull"},{"type":"text","text":" "},{"type":"text","text":"request and one for running on a branch which should create releases."},{"text":" ","type":"text"},{"text":"The two commands behave almost exactly the same, so once you’ve learned one","type":"text"},{"type":"text","text":" "},{"text":"there isn’t much to learn about the other.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These commands were designed for the place we need them in our automation, so"},{"type":"text","text":" "},{"type":"text","text":"let’s talk about how the pull request and release automation works. Throughout"},{"type":"text","text":" "},{"type":"text","text":"the remainder of this, I’m going to call the Swift Conventional Commit Parser"},{"type":"text","text":" "},{"text":"the “commit parsing tool” or “the tool” for the sake of brevity.","type":"text"}]},{"level":3,"anchor":"Pull-Request-Automation","type":"heading","text":"Pull Request Automation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"I choose to use the commit parsing tool in the part of my pull request"},{"text":" ","type":"text"},{"type":"text","text":"automation that runs tests. I do that because I use Danger Swift in that"},{"text":" ","type":"text"},{"type":"text","text":"automation to report test results back to the pull request and it is simple to"},{"type":"text","text":" "},{"text":"add the extra information from the commit parsing tool. This is what my ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-pull-request-action.yml#L15","type":"reference"},{"text":" looks like today for that automation:","type":"text"}]},{"code":["...","jobs:","...","  test:","    runs-on: macos-14","    env:","      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}","      TARGET_BRANCH: ${{ github.base_ref }}","    steps:","      - uses: actions\/checkout@v4","        with:","          fetch-depth: 0","      - name: Run Tests","        run: |","          git clone -b apple https:\/\/github.com\/DavidBrunow\/CI-Tooling.git CI-Tooling --depth 1","          .\/CI-Tooling\/unpack.sh","          .\/create_fixtures.sh","          gem install xcpretty","          gem install xcpretty-json-formatter","          defaults write com.apple.dt.Xcode IDESkipMacroFingerprintValidation -bool YES","          brew install jq","          export SCHEME=`xcodebuild -list -json | jq -r '.workspace.schemes[0]'`","          xcodebuild test -scheme $SCHEME -destination \"OS=13.0\" -derivedDataPath ..\/DerivedDataTests -enableCodeCoverage YES -resultBundlePath ..\/DerivedDataTests\/coverage.xcresult | XCPRETTY_JSON_FILE_OUTPUT=result.json xcpretty -f `xcpretty-json-formatter`","          defaults write com.apple.dt.Xcode IDESkipMacroFingerprintValidation -bool NO","          brew install npm","          npm install -g danger","          .\/CI-Tooling\/swift-conventional-commit-parser pull-request -t \"origin\/$TARGET_BRANCH\" > release_notes.json || true","          .\/CI-Tooling\/danger-swift ci"],"type":"codeListing","syntax":"yaml"},{"type":"paragraph","inlineContent":[{"text":"There is a lot of noise in there that isn’t completely relevant to what we’re","type":"text"},{"text":" ","type":"text"},{"text":"talking about here, but I think the extra context is useful for seeing how","type":"text"},{"type":"text","text":" "},{"type":"text","text":"things fit together."}]},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"This example uses my shared CI Tooling repo pattern, which stores","type":"text"},{"type":"text","text":" "},{"type":"text","text":"everything needed for CI in one repo. You can learn more about that in my"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/04-21-ci-tooling","overridingTitle":"blog post about it","overridingTitleInlineContent":[{"text":"blog post about it","type":"text"}]},{"text":".","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"text":"The key part for this discussion comes on the next to last line, where the","type":"text"},{"text":" ","type":"text"},{"text":"parser tool is called:","type":"text"}]},{"type":"codeListing","code":[".\/CI-Tooling\/swift-conventional-commit-parser pull-request \\","  -t \"origin\/$TARGET_BRANCH\" \\","  2> swift_conventional_commit_parser_error.txt \\","  > release_notes.json \\","  || true"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"This command takes in a target branch, which we’re passing along from the pull"},{"type":"text","text":" "},{"type":"text","text":"request’s target branch, and outputs any errors to a file called error.txt and"},{"type":"text","text":" "},{"text":"any successful output to a file called ","type":"text"},{"type":"codeVoice","code":"release_notes.json"},{"type":"text","text":". The "},{"code":"|| true","type":"codeVoice"},{"text":" at","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the end ensures that this command does not exit in an error. This is needed to"},{"type":"text","text":" "},{"type":"text","text":"ensure the pipeline continues running and allows Danger Swift to report"},{"text":" ","type":"text"},{"type":"text","text":"everything, including any errors, back to the pull request."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The only error the tool will emit is when there are no formatted commits on the"},{"type":"text","text":" "},{"text":"pull request branch. This error message is a great place to help folks learn","type":"text"},{"type":"text","text":" "},{"type":"text","text":"about Conventional Commits and can be customized using the optional "},{"code":"-n","type":"codeVoice"},{"type":"text","text":" "},{"text":"argument to pass in your own error message, which could link to how you use","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Conventional Commits in your CI system. By default, the error message links to"},{"type":"text","text":" "},{"type":"text","text":"the README on the Swift Conventional Commit Parser repo, which talks about how"},{"type":"text","text":" "},{"type":"text","text":"I use Conventional Commits."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The standard output from the tool is JSON. Here is an example:"}]},{"type":"codeListing","syntax":"json","code":["{","  \"bumpType\" : \"minor\",","  \"releaseNotes\" : \"## [1.1.0] - 1970-01-01\\n\\n### Features\\n* Awesome feature","(abcdef)\\n\\n### Chores\\n* Change the \\\"total\\\" field (abcdef)\",","  \"version\" : \"1.1.0\"","}"]},{"inlineContent":[{"text":"We can take this output, or the error message, and ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/Dangerfile.swift#L6"},{"text":" ","type":"text"},{"text":"to report back to the pull request:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["if FileManager.default.fileExists(atPath: \"release_notes.json\"),","  let contents = FileManager.default.contents(atPath: \"release_notes.json\"),","  let jsonObject = try? JSONSerialization.jsonObject(","    with: contents, ","    options: []","  ) as? [String: Any],","  let releaseNotes = jsonObject[\"releaseNotes\"] as? String {","  markdown(\"Release notes:\\n\\(releaseNotes)\")","} else if FileManager.default.fileExists(atPath: \"swift_conventional_commit_parser_error.txt\"),","  let contents = FileManager.default.contents(atPath: \"swift_conventional_commit_parser_error.txt\"),","  let errorMessage = String(data: contents, encoding: .utf8),","  errorMessage.isEmpty == false {","  fail(errorMessage)","} else {","  fail(\"No formatted commit.\")","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This code in the Dangerfile will output errors on the pull request like this:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"conventionalCommitParserErrorFromDanger"}]},{"inlineContent":[{"text":"And will output the release notes on the pull request like this:","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"conventionalCommitParserReleaseNotesFromDanger","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And that’s what it takes to make the pull request automation functional and"},{"type":"text","text":" "},{"type":"text","text":"ergonomic. Next, let’s talk about the release automation."}]},{"text":"Release Automation","type":"heading","anchor":"Release-Automation","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The commit parsing tool also needs to run on merges to release branches and the"},{"type":"text","text":" "},{"type":"text","text":"release command is built for that. The tool acts the same way as for pull"},{"type":"text","text":" "},{"text":"requests, with the exception of not needing to pass in a target branch. Here is","type":"text"},{"text":" ","type":"text"},{"text":"what the ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-release-action.yml#L7"},{"text":" ","type":"text"},{"text":"looks like today for the release automation of macOS command line tools:","type":"text"}]},{"code":["...","jobs:","  release:","    runs-on: macos-14","    steps:","      - uses: actions\/create-github-app-token@v1","        id: app-token","        with:","          app-id: ${{ vars.RELEASE_BOT_APPID }}","          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}","      - uses: actions\/checkout@v4","        with:","          fetch-depth: 0","          token: ${{ steps.app-token.outputs.token }}","      - name: Release","        run: |","          git clone -b apple https:\/\/github.com\/DavidBrunow\/CI-Tooling.git CI-Tooling --depth 1","          .\/CI-Tooling\/unpack.sh","          brew install jq","          # Run conventional commit parser","          CONVENTIONAL_COMMIT_PARSER_OUTPUT=`.\/CI-Tooling\/swift-conventional-commit-parser release`","          if [[ \"$BUMP_TYPE\" == \"none\" ]]; then exit 0; fi","          VERSION=`jq -r '.version' <<<\"$CONVENTIONAL_COMMIT_PARSER_OUTPUT\"`","          RELEASE_NOTES=`jq -r '.releaseNotes' <<<\"$CONVENTIONAL_COMMIT_PARSER_OUTPUT\"`","          # Bump version","          FILE_THAT_NEEDS_VERSION_UPDATE=`grep -lr \"@main\" .\/Sources`","          sed -i '' -E \"s\/(version: \\\").*(\\\")\/\\1$VERSION\\2\/\" $FILE_THAT_NEEDS_VERSION_UPDATE","          # Update CHANGELOG","          RELEASE_NOTES=`sed 's\/$\/\\\\\\\\\/g' <<<\"$RELEASE_NOTES\"`","          sed -i '' -f - .\/CHANGELOG.md <<EOF","          7 i\\\\","          \\\\","          $RELEASE_NOTES","          EOF","          # Push changes without running CI","          git add $FILE_THAT_NEEDS_VERSION_UPDATE","          git add CHANGELOG.md","          git commit -m \"Release $VERSION [skip ci]\"","          # Add tag","          git tag \"$VERSION\"","          git push origin","          git push origin \"$VERSION\""],"type":"codeListing","syntax":"yml"},{"type":"aside","style":"warning","content":[{"inlineContent":[{"text":"In order for the automation to be able to push to a protected branch,","type":"text"},{"text":" ","type":"text"},{"text":"I created a GitHub App which I can use as a bot and then added that bot to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"bypass list for the ruleset that is protecting branches."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"While setting that up is outside the scope of this post, I do want to note"},{"text":" ","type":"text"},{"type":"text","text":"that this can be dangerous if setup incorrectly. Before doing so, ensure you"},{"type":"text","text":" "},{"type":"text","text":"consider that anyone with write access to the repository would theoretically"},{"type":"text","text":" "},{"text":"be able to modify a GitHub Action workflow to push changes to those protected","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"branches. This works fine for me because I am not giving write access to"},{"type":"text","text":" "},{"text":"anyone else – your approach will vary based upon your needs.","type":"text"}],"type":"paragraph"}],"name":"Warning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This automation first installs "},{"type":"reference","isActive":true,"identifier":"https:\/\/jqlang.github.io\/jq\/"},{"type":"text","text":" because we’ll"},{"text":" ","type":"text"},{"text":"be doing all our JSON parsing of the tool’s output in the automation’s shell","type":"text"},{"text":" ","type":"text"},{"text":"script. If the ","type":"text"},{"type":"codeVoice","code":"bumpType"},{"type":"text","text":" is equal to “none”, and therefore no release is"},{"text":" ","type":"text"},{"type":"text","text":"needed, the automation exits early. Otherwise, the release notes are added to"},{"type":"text","text":" "},{"text":"the changelog, the code’s version is updated, the changes are added and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"committed to git, the repo is tagged, and all the changes are pushed to origin."},{"type":"text","text":" "},{"type":"text","text":"The details about how this automation works is specific to the way I have my"},{"type":"text","text":" "},{"text":"codebases setup, but the general process would be the same for any codebase.","type":"text"}]},{"inlineContent":[{"text":"With this automation in place, every commit to a release branch creates a new,","type":"text"},{"text":" ","type":"text"},{"text":"properly semantically versioned release that can be distributed to your users.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"That’s all it takes to setup this automated semantic versioning. Next I’ll talk","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"about some approaches for this kind of automation that I rejected, in case"},{"type":"text","text":" "},{"text":"you’re interested.","type":"text"}]},{"level":2,"type":"heading","text":"Rejected Alternative Approaches","anchor":"Rejected-Alternative-Approaches"},{"inlineContent":[{"type":"text","text":"When figuring out how to automate versioning a few years ago, I considered and"},{"type":"text","text":" "},{"type":"text","text":"rejected a couple of approaches. I think it is useful to talk through why I"},{"type":"text","text":" "},{"text":"rejected them, because at first glance they seem like a simpler approach than","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"what I follow today. Plus, talking through them reveals what is important about"},{"type":"text","text":" "},{"type":"text","text":"the problem space of automating versioning. I’ll also talk through another"},{"type":"text","text":" "},{"type":"text","text":"approach that I did not consider a few years ago but that I think is relevant to"},{"text":" ","type":"text"},{"text":"the thought process:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Always bumping the patch version for any non-breaking changes","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Using specially formatted branch names"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using specially formatted pull request titles"}]}]}]},{"text":"Rejected approach: Always bumping the patch version for any non-breaking changes","anchor":"Rejected-approach-Always-bumping-the-patch-version-for-any-non-breaking-changes","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"This is an approach that I didn’t consider when I first starting thinking about","type":"text"},{"type":"text","text":" "},{"text":"automating versioning, but I’ve recently heard that other folks might be doing","type":"text"},{"type":"text","text":" "},{"type":"text","text":"this for their build automation. I’d reject this approach for a few reasons:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Always bumping the patch version means that you aren’t actually following"},{"text":" ","type":"text"},{"text":"semantic versioning, and I believe the most value you get out of semantic","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"versioning is in the “semantic” part of it. Always bumping the patch version"},{"type":"text","text":" "},{"type":"text","text":"loses the semantic meaning of a version, which brings me to my second reason."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As a client of a library that bumps versions like this, I cannot"},{"type":"text","text":" "},{"type":"text","text":"trust the versioning to provide me with any information about how easy it will"},{"type":"text","text":" "},{"text":"be to adopt the changes.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you always bump the patch version, there is no “room” between versions to"},{"type":"text","text":" "},{"text":"make a hotfix. For example, if I need to make a hotfix for version 1.0.1 but","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"versions 1.0.2, 1.0.3, 1.0.4, and 1.0.5 have already been created, I have to get"},{"text":" ","type":"text"},{"type":"text","text":"creative in my version naming to create a version between 1.0.1 and 1.0.2. If I"},{"text":" ","type":"text"},{"type":"text","text":"were OK with the first point above, I’d bump the minor version by default to"},{"text":" ","type":"text"},{"text":"avoid this issue – but I’m definitely not OK with the first point.","type":"text"}]}]}],"type":"orderedList"},{"type":"heading","text":"Rejected approach: Using specially formatted branch names","level":3,"anchor":"Rejected-approach-Using-specially-formatted-branch-names"},{"inlineContent":[{"text":"I considered using specially formatted branch names, but that approach meant you","type":"text"},{"type":"text","text":" "},{"text":"either needed to know what kind of change you would be making when you started","type":"text"},{"text":" ","type":"text"},{"text":"your effort, or you would have to change your branch name later in the effort to","type":"text"},{"type":"text","text":" "},{"text":"match the type of change. And while I like small efforts, one change per branch","type":"text"},{"type":"text","text":" "},{"text":"seemed overly limiting. Plus, in git, branches are ephemeral. I believe that any","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"automated versioning should be idempotent and stable over time – no matter how"},{"type":"text","text":" "},{"text":"many times it is run, given the same inputs it should always produce the same","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"versions – and that would not be true when using branch names due to their"},{"text":" ","type":"text"},{"type":"text","text":"inherent instability. Therefore I believe we should base our versioning on"},{"text":" ","type":"text"},{"type":"text","text":"things that git considers to be more stable."}],"type":"paragraph"},{"type":"heading","anchor":"Rejected-approach-Using-specially-formatted-pull-request-titles","text":"Rejected approach: Using specially formatted pull request titles","level":3},{"type":"paragraph","inlineContent":[{"text":"After rejecting specially formatted branch names, I considered something more","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"flexible – pull request titles. Since pull request titles can be changed at any"},{"type":"text","text":" "},{"text":"point in the pull request process, one could change the format of it without","type":"text"},{"type":"text","text":" "},{"type":"text","text":"disrupting the remainder of the workflow too much since you don’t need to create"},{"text":" ","type":"text"},{"type":"text","text":"a new pull request. But this approach has many of the same limitations as using"},{"type":"text","text":" "},{"type":"text","text":"branch names around one change per pull request and the automated versioning not"},{"type":"text","text":" "},{"type":"text","text":"being idempotent and stable over time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even worse, this approach would couple your automated versioning to your source"},{"type":"text","text":" "},{"type":"text","text":"control platform (GitHub, GitLab, etc.), which would be overly limiting in the"},{"type":"text","text":" "},{"type":"text","text":"long term."}]},{"text":"Footnotes","type":"heading","level":2,"anchor":"Footnotes"},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/05-27-automating-release-versioning#Implementing-Conventional-Commit-Parsing","isActive":true,"overridingTitle":"1","overridingTitleInlineContent":[{"type":"text","text":"1"}]},{"type":"text","text":": There are "},{"isActive":true,"type":"reference","identifier":"https:\/\/www.conventionalcommits.org\/en\/about\/#tooling-for-conventional-commits"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"many of those may fit your needs as well, but I know my tool better than those."}]}],"kind":"content"}],"identifier":{"url":"doc:\/\/Brunow\/documentation\/Brunow\/05-27-automating-release-versioning","interfaceLanguage":"swift"},"kind":"article","abstract":[{"type":"text","text":"Implementing tools and patterns to ship code as soon as it is ready."}],"topicSectionsStyle":"detailedGrid","schemaVersion":{"major":0,"patch":0,"minor":3},"variants":[{"paths":["\/documentation\/brunow\/05-27-automating-release-versioning"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"hierarchy":{"paths":[["doc:\/\/Brunow\/documentation\/Brunow"],["doc:\/\/Brunow\/documentation\/Brunow","doc:\/\/Brunow\/documentation\/Brunow\/Archive","doc:\/\/Brunow\/documentation\/Brunow\/2024"]]},"references":{"conventionalCommitParserReleaseNotesFromDanger":{"variants":[{"url":"\/images\/Brunow\/conventionalCommitParserReleaseNotesFromDanger@2x.png","traits":["2x","light"]}],"type":"image","identifier":"conventionalCommitParserReleaseNotesFromDanger","alt":"Screenshot of pull request comment showing release notes generated by the commit parsing tool. The release notes have a heading with the version and the date, and then sections for “Features” and “Chores”. Each of the items under the features and chores has a description of the change and the commit hash."},"doc://Brunow/documentation/Brunow/05-27-automating-release-versioning#Footnotes":{"url":"\/documentation\/brunow\/05-27-automating-release-versioning#Footnotes","type":"topic","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/05-27-automating-release-versioning#Footnotes","title":"Footnotes","abstract":[],"kind":"section"},"allChecksHavePassed.png":{"variants":[{"url":"\/images\/Brunow\/allChecksHavePassed@1x.png","traits":["1x","light"]}],"type":"image","identifier":"allChecksHavePassed.png","alt":"Screenshot of the GitHub interface showing that all CI checks have passed."},"https://github.com/DavidBrunow/CI-Tooling/blob/apple/Dangerfile.swift#L6":{"url":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/Dangerfile.swift#L6","type":"link","titleInlineContent":[{"type":"text","text":"use it in the Dangerfile"}],"identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/Dangerfile.swift#L6","title":"use it in the Dangerfile"},"doc://Brunow/documentation/Brunow/Archive":{"title":"Archive","role":"collectionGroup","abstract":[{"text":"All posts","type":"text"}],"identifier":"doc:\/\/Brunow\/documentation\/Brunow\/Archive","kind":"article","url":"\/documentation\/brunow\/archive","type":"topic"},"doc://Brunow/documentation/Brunow":{"title":"Brunow","kind":"symbol","url":"\/documentation\/brunow","identifier":"doc:\/\/Brunow\/documentation\/Brunow","abstract":[{"type":"text","text":"David Brunow, known as Brunow [ˈbɹunoʊ] to the folks he works with, is a human living on Earth. You might have something in common with him — if you think it is ridiculous that he is talking about himself in the first person here, so does he."}],"role":"collection","type":"topic"},"https://www.conventionalcommits.org/en/v1.0.0/":{"url":"https:\/\/www.conventionalcommits.org\/en\/v1.0.0\/","type":"link","titleInlineContent":[{"text":"Conventional Commits","type":"text"}],"identifier":"https:\/\/www.conventionalcommits.org\/en\/v1.0.0\/","title":"Conventional Commits"},"conventionalCommitParserErrorFromDanger":{"variants":[{"url":"\/images\/Brunow\/conventionalCommitParserErrorFromDanger@2x.png","traits":["2x","light"]}],"type":"image","identifier":"conventionalCommitParserErrorFromDanger","alt":"Screenshot of pull request comment showing that there was an error due to no formatted commits being found. This error also has a link to documentation to learn more about Conventional Commits."},"conventionalCommitParserReleaseNotesFromDanger.png":{"variants":[{"url":"\/images\/Brunow\/conventionalCommitParserReleaseNotesFromDanger@2x.png","traits":["2x","light"]}],"type":"image","identifier":"conventionalCommitParserReleaseNotesFromDanger.png","alt":null},"doc://Brunow/documentation/Brunow/05-27-automating-release-versioning#Implementing-Conventional-Commit-Parsing":{"url":"\/documentation\/brunow\/05-27-automating-release-versioning#Implementing-Conventional-Commit-Parsing","type":"topic","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/05-27-automating-release-versioning#Implementing-Conventional-Commit-Parsing","title":"Implementing Conventional Commit Parsing","abstract":[],"kind":"section"},"https://jqlang.github.io/jq/":{"url":"https:\/\/jqlang.github.io\/jq\/","type":"link","titleInlineContent":[{"type":"text","text":"jq"}],"identifier":"https:\/\/jqlang.github.io\/jq\/","title":"jq"},"https://github.com/DavidBrunow/CI-Tooling/blob/apple/.github/workflows/macos-tools-release-action.yml#L7":{"url":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-release-action.yml#L7","type":"link","titleInlineContent":[{"text":"GitHub Action YAML","type":"text"}],"identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-release-action.yml#L7","title":"GitHub Action YAML"},"doc://Brunow/documentation/Brunow/2024":{"title":"2024","url":"\/documentation\/brunow\/2024","kind":"article","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/2024","type":"topic","role":"collectionGroup","abstract":[]},"https://www.conventionalcommits.org/en/about/#tooling-for-conventional-commits":{"url":"https:\/\/www.conventionalcommits.org\/en\/about\/#tooling-for-conventional-commits","type":"link","titleInlineContent":[{"type":"text","text":"many other tools out there that can parse conventional commits"}],"identifier":"https:\/\/www.conventionalcommits.org\/en\/about\/#tooling-for-conventional-commits","title":"many other tools out there that can parse conventional commits"},"https://github.com/DavidBrunow/CI-Tooling/blob/apple/.github/workflows/macos-tools-pull-request-action.yml#L15":{"url":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-pull-request-action.yml#L15","type":"link","titleInlineContent":[{"text":"GitHub","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Action YAML for macOS command line tools"}],"identifier":"https:\/\/github.com\/DavidBrunow\/CI-Tooling\/blob\/apple\/.github\/workflows\/macos-tools-pull-request-action.yml#L15","title":"GitHub Action YAML for macOS command line tools"},"https://github.com/DavidBrunow/swift-conventional-commit-parser":{"url":"https:\/\/github.com\/DavidBrunow\/swift-conventional-commit-parser","type":"link","titleInlineContent":[{"type":"text","text":"Swift Conventional Commit Parser"}],"identifier":"https:\/\/github.com\/DavidBrunow\/swift-conventional-commit-parser","title":"Swift Conventional Commit Parser"},"doc://Brunow/documentation/Brunow/04-21-ci-tooling":{"kind":"article","role":"article","type":"topic","identifier":"doc:\/\/Brunow\/documentation\/Brunow\/04-21-ci-tooling","url":"\/documentation\/brunow\/04-21-ci-tooling","abstract":[{"text":"Storing CI tools in a centralized location to be used across the pipelines for","type":"text"},{"type":"text","text":" "},{"type":"text","text":"multiple projects."}],"title":"CI Tooling","images":[{"type":"card","identifier":"allChecksHavePassed.png"}]}}}